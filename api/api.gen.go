// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for DurationEventRequestDisplayColor.
const (
	DurationEventRequestDisplayColorBlue   DurationEventRequestDisplayColor = "blue"
	DurationEventRequestDisplayColorGreen  DurationEventRequestDisplayColor = "green"
	DurationEventRequestDisplayColorOrange DurationEventRequestDisplayColor = "orange"
	DurationEventRequestDisplayColorPink   DurationEventRequestDisplayColor = "pink"
	DurationEventRequestDisplayColorPurple DurationEventRequestDisplayColor = "purple"
	DurationEventRequestDisplayColorRed    DurationEventRequestDisplayColor = "red"
)

// Defines values for DurationEventRequestType.
const (
	DurationEventRequestTypeDuration DurationEventRequestType = "duration"
)

// Defines values for DurationEventResponseDisplayColor.
const (
	DurationEventResponseDisplayColorBlue   DurationEventResponseDisplayColor = "blue"
	DurationEventResponseDisplayColorGreen  DurationEventResponseDisplayColor = "green"
	DurationEventResponseDisplayColorOrange DurationEventResponseDisplayColor = "orange"
	DurationEventResponseDisplayColorPink   DurationEventResponseDisplayColor = "pink"
	DurationEventResponseDisplayColorPurple DurationEventResponseDisplayColor = "purple"
	DurationEventResponseDisplayColorRed    DurationEventResponseDisplayColor = "red"
)

// Defines values for DurationEventResponseType.
const (
	DurationEventResponseTypeDuration DurationEventResponseType = "duration"
)

// Defines values for FreeNumberAnswerRequestType.
const (
	FreeNumberAnswerRequestTypeFreeNumber FreeNumberAnswerRequestType = "free_number"
)

// Defines values for FreeNumberAnswerResponseType.
const (
	FreeNumberAnswerResponseTypeFreeNumber FreeNumberAnswerResponseType = "free_number"
)

// Defines values for FreeNumberQuestionRequestType.
const (
	FreeNumberQuestionRequestTypeFreeNumber FreeNumberQuestionRequestType = "free_number"
)

// Defines values for FreeNumberQuestionResponseType.
const (
	FreeNumberQuestionResponseTypeFreeNumber FreeNumberQuestionResponseType = "free_number"
)

// Defines values for FreeTextAnswerRequestType.
const (
	FreeTextAnswerRequestTypeFreeText FreeTextAnswerRequestType = "free_text"
)

// Defines values for FreeTextAnswerResponseType.
const (
	FreeTextAnswerResponseTypeFreeText FreeTextAnswerResponseType = "free_text"
)

// Defines values for FreeTextQuestionRequestType.
const (
	FreeTextQuestionRequestTypeFreeText FreeTextQuestionRequestType = "free_text"
)

// Defines values for FreeTextQuestionResponseType.
const (
	FreeTextQuestionResponseTypeFreeText FreeTextQuestionResponseType = "free_text"
)

// Defines values for MomentEventRequestType.
const (
	MomentEventRequestTypeMoment MomentEventRequestType = "moment"
)

// Defines values for MomentEventResponseType.
const (
	MomentEventResponseTypeMoment MomentEventResponseType = "moment"
)

// Defines values for MultipleChoiceAnswerRequestType.
const (
	MultipleChoiceAnswerRequestTypeMultiple MultipleChoiceAnswerRequestType = "multiple"
)

// Defines values for MultipleChoiceAnswerResponseType.
const (
	MultipleChoiceAnswerResponseTypeMultiple MultipleChoiceAnswerResponseType = "multiple"
)

// Defines values for MultipleChoiceQuestionRequestType.
const (
	MultipleChoiceQuestionRequestTypeMultiple MultipleChoiceQuestionRequestType = "multiple"
)

// Defines values for MultipleChoiceQuestionResponseType.
const (
	MultipleChoiceQuestionResponseTypeMultiple MultipleChoiceQuestionResponseType = "multiple"
)

// Defines values for OfficialEventRequestType.
const (
	OfficialEventRequestTypeOfficial OfficialEventRequestType = "official"
)

// Defines values for OfficialEventResponseType.
const (
	OfficialEventResponseTypeOfficial OfficialEventResponseType = "official"
)

// Defines values for SingleChoiceAnswerRequestType.
const (
	SingleChoiceAnswerRequestTypeSingle SingleChoiceAnswerRequestType = "single"
)

// Defines values for SingleChoiceAnswerResponseType.
const (
	SingleChoiceAnswerResponseTypeSingle SingleChoiceAnswerResponseType = "single"
)

// Defines values for SingleChoiceQuestionRequestType.
const (
	SingleChoiceQuestionRequestTypeSingle SingleChoiceQuestionRequestType = "single"
)

// Defines values for SingleChoiceQuestionResponseType.
const (
	SingleChoiceQuestionResponseTypeSingle SingleChoiceQuestionResponseType = "single"
)

// AnswerRequest defines model for AnswerRequest.
type AnswerRequest struct {
	union json.RawMessage
}

// AnswerResponse defines model for AnswerResponse.
type AnswerResponse struct {
	union json.RawMessage
}

// CampRequest defines model for CampRequest.
type CampRequest struct {
	DateEnd            openapi_types.Date `json:"dateEnd"`
	DateStart          openapi_types.Date `json:"dateStart"`
	Description        string             `json:"description"`
	DisplayId          string             `json:"displayId"`
	IsDraft            bool               `json:"isDraft"`
	IsPaymentOpen      bool               `json:"isPaymentOpen"`
	IsRegistrationOpen bool               `json:"isRegistrationOpen"`
	Name               string             `json:"name"`
}

// CampResponse defines model for CampResponse.
type CampResponse struct {
	DateEnd            openapi_types.Date `json:"dateEnd"`
	DateStart          openapi_types.Date `json:"dateStart"`
	Description        string             `json:"description"`
	DisplayId          string             `json:"displayId"`
	Id                 int                `json:"id"`
	IsDraft            bool               `json:"isDraft"`
	IsPaymentOpen      bool               `json:"isPaymentOpen"`
	IsRegistrationOpen bool               `json:"isRegistrationOpen"`
	Name               string             `json:"name"`
}

// DashboardResponse defines model for DashboardResponse.
type DashboardResponse struct {
	Id      string           `json:"id"`
	Payment *PaymentResponse `json:"payment,omitempty"`
	Room    *RoomResponse    `json:"room,omitempty"`
}

// DurationEventRequest defines model for DurationEventRequest.
type DurationEventRequest struct {
	Description  string                           `json:"description"`
	DisplayColor DurationEventRequestDisplayColor `json:"displayColor"`
	Location     string                           `json:"location"`
	Name         string                           `json:"name"`
	OrganizerId  string                           `json:"organizerId"`
	TimeEnd      time.Time                        `json:"timeEnd"`
	TimeStart    time.Time                        `json:"timeStart"`
	Type         DurationEventRequestType         `json:"type"`
}

// DurationEventRequestDisplayColor defines model for DurationEventRequest.DisplayColor.
type DurationEventRequestDisplayColor string

// DurationEventRequestType defines model for DurationEventRequest.Type.
type DurationEventRequestType string

// DurationEventResponse defines model for DurationEventResponse.
type DurationEventResponse struct {
	Description  string                            `json:"description"`
	DisplayColor DurationEventResponseDisplayColor `json:"displayColor"`
	Id           int                               `json:"id"`
	Location     string                            `json:"location"`
	Name         string                            `json:"name"`
	OrganizerId  string                            `json:"organizerId"`
	TimeEnd      time.Time                         `json:"timeEnd"`
	TimeStart    time.Time                         `json:"timeStart"`
	Type         DurationEventResponseType         `json:"type"`
}

// DurationEventResponseDisplayColor defines model for DurationEventResponse.DisplayColor.
type DurationEventResponseDisplayColor string

// DurationEventResponseType defines model for DurationEventResponse.Type.
type DurationEventResponseType string

// EventRequest defines model for EventRequest.
type EventRequest struct {
	union json.RawMessage
}

// EventResponse defines model for EventResponse.
type EventResponse struct {
	union json.RawMessage
}

// FreeNumberAnswerRequest defines model for FreeNumberAnswerRequest.
type FreeNumberAnswerRequest struct {
	Content    float32                     `json:"content"`
	QuestionId int                         `json:"questionId"`
	Type       FreeNumberAnswerRequestType `json:"type"`
}

// FreeNumberAnswerRequestType defines model for FreeNumberAnswerRequest.Type.
type FreeNumberAnswerRequestType string

// FreeNumberAnswerResponse defines model for FreeNumberAnswerResponse.
type FreeNumberAnswerResponse struct {
	Content    float32                      `json:"content"`
	Id         int                          `json:"id"`
	QuestionId int                          `json:"questionId"`
	Type       FreeNumberAnswerResponseType `json:"type"`
	UserId     string                       `json:"userId"`
}

// FreeNumberAnswerResponseType defines model for FreeNumberAnswerResponse.Type.
type FreeNumberAnswerResponseType string

// FreeNumberQuestionRequest defines model for FreeNumberQuestionRequest.
type FreeNumberQuestionRequest struct {
	Description *string                       `json:"description,omitempty"`
	IsOpen      bool                          `json:"isOpen"`
	IsPublic    bool                          `json:"isPublic"`
	Title       string                        `json:"title"`
	Type        FreeNumberQuestionRequestType `json:"type"`
}

// FreeNumberQuestionRequestType defines model for FreeNumberQuestionRequest.Type.
type FreeNumberQuestionRequestType string

// FreeNumberQuestionResponse defines model for FreeNumberQuestionResponse.
type FreeNumberQuestionResponse struct {
	Description *string                        `json:"description"`
	Id          int                            `json:"id"`
	IsOpen      bool                           `json:"isOpen"`
	IsPublic    bool                           `json:"isPublic"`
	Title       string                         `json:"title"`
	Type        FreeNumberQuestionResponseType `json:"type"`
}

// FreeNumberQuestionResponseType defines model for FreeNumberQuestionResponse.Type.
type FreeNumberQuestionResponseType string

// FreeTextAnswerRequest defines model for FreeTextAnswerRequest.
type FreeTextAnswerRequest struct {
	Content    string                    `json:"content"`
	QuestionId int                       `json:"questionId"`
	Type       FreeTextAnswerRequestType `json:"type"`
}

// FreeTextAnswerRequestType defines model for FreeTextAnswerRequest.Type.
type FreeTextAnswerRequestType string

// FreeTextAnswerResponse defines model for FreeTextAnswerResponse.
type FreeTextAnswerResponse struct {
	Content    string                     `json:"content"`
	Id         int                        `json:"id"`
	QuestionId int                        `json:"questionId"`
	Type       FreeTextAnswerResponseType `json:"type"`
	UserId     string                     `json:"userId"`
}

// FreeTextAnswerResponseType defines model for FreeTextAnswerResponse.Type.
type FreeTextAnswerResponseType string

// FreeTextQuestionRequest defines model for FreeTextQuestionRequest.
type FreeTextQuestionRequest struct {
	Description *string                     `json:"description,omitempty"`
	IsOpen      bool                        `json:"isOpen"`
	IsPublic    bool                        `json:"isPublic"`
	Title       string                      `json:"title"`
	Type        FreeTextQuestionRequestType `json:"type"`
}

// FreeTextQuestionRequestType defines model for FreeTextQuestionRequest.Type.
type FreeTextQuestionRequestType string

// FreeTextQuestionResponse defines model for FreeTextQuestionResponse.
type FreeTextQuestionResponse struct {
	Description *string                      `json:"description"`
	Id          int                          `json:"id"`
	IsOpen      bool                         `json:"isOpen"`
	IsPublic    bool                         `json:"isPublic"`
	Title       string                       `json:"title"`
	Type        FreeTextQuestionResponseType `json:"type"`
}

// FreeTextQuestionResponseType defines model for FreeTextQuestionResponse.Type.
type FreeTextQuestionResponseType string

// ImageResponse defines model for ImageResponse.
type ImageResponse struct {
	Id int `json:"id"`
}

// MessageRequest defines model for MessageRequest.
type MessageRequest struct {
	Content string    `json:"content"`
	SendAt  time.Time `json:"sendAt"`
}

// MomentEventRequest defines model for MomentEventRequest.
type MomentEventRequest struct {
	Description string                 `json:"description"`
	Location    string                 `json:"location"`
	Name        string                 `json:"name"`
	Time        time.Time              `copier:"TimeStart" json:"time"`
	Type        MomentEventRequestType `json:"type"`
}

// MomentEventRequestType defines model for MomentEventRequest.Type.
type MomentEventRequestType string

// MomentEventResponse defines model for MomentEventResponse.
type MomentEventResponse struct {
	Description string                  `json:"description"`
	Id          int                     `json:"id"`
	Location    string                  `json:"location"`
	Name        string                  `json:"name"`
	Time        time.Time               `copier:"TimeStart" json:"time"`
	Type        MomentEventResponseType `json:"type"`
}

// MomentEventResponseType defines model for MomentEventResponse.Type.
type MomentEventResponseType string

// MultipleChoiceAnswerRequest defines model for MultipleChoiceAnswerRequest.
type MultipleChoiceAnswerRequest struct {
	OptionIds  []int                           `json:"optionIds"`
	QuestionId int                             `json:"questionId"`
	Type       MultipleChoiceAnswerRequestType `json:"type"`
}

// MultipleChoiceAnswerRequestType defines model for MultipleChoiceAnswerRequest.Type.
type MultipleChoiceAnswerRequestType string

// MultipleChoiceAnswerResponse defines model for MultipleChoiceAnswerResponse.
type MultipleChoiceAnswerResponse struct {
	Id              int                              `json:"id"`
	QuestionId      int                              `json:"questionId"`
	SelectedOptions []OptionResponse                 `json:"selectedOptions"`
	Type            MultipleChoiceAnswerResponseType `json:"type"`
	UserId          string                           `json:"userId"`
}

// MultipleChoiceAnswerResponseType defines model for MultipleChoiceAnswerResponse.Type.
type MultipleChoiceAnswerResponseType string

// MultipleChoiceQuestionRequest defines model for MultipleChoiceQuestionRequest.
type MultipleChoiceQuestionRequest struct {
	Description *string                           `json:"description,omitempty"`
	IsOpen      bool                              `json:"isOpen"`
	IsPublic    bool                              `json:"isPublic"`
	Options     []OptionRequest                   `json:"options"`
	Title       string                            `json:"title"`
	Type        MultipleChoiceQuestionRequestType `json:"type"`
}

// MultipleChoiceQuestionRequestType defines model for MultipleChoiceQuestionRequest.Type.
type MultipleChoiceQuestionRequestType string

// MultipleChoiceQuestionResponse defines model for MultipleChoiceQuestionResponse.
type MultipleChoiceQuestionResponse struct {
	Description *string                            `json:"description"`
	Id          int                                `json:"id"`
	IsOpen      bool                               `json:"isOpen"`
	IsPublic    bool                               `json:"isPublic"`
	Options     []OptionResponse                   `json:"options"`
	Title       string                             `json:"title"`
	Type        MultipleChoiceQuestionResponseType `json:"type"`
}

// MultipleChoiceQuestionResponseType defines model for MultipleChoiceQuestionResponse.Type.
type MultipleChoiceQuestionResponseType string

// OfficialEventRequest defines model for OfficialEventRequest.
type OfficialEventRequest struct {
	Description string                   `json:"description"`
	Location    string                   `json:"location"`
	Name        string                   `json:"name"`
	TimeEnd     time.Time                `json:"timeEnd"`
	TimeStart   time.Time                `json:"timeStart"`
	Type        OfficialEventRequestType `json:"type"`
}

// OfficialEventRequestType defines model for OfficialEventRequest.Type.
type OfficialEventRequestType string

// OfficialEventResponse defines model for OfficialEventResponse.
type OfficialEventResponse struct {
	Description string                    `json:"description"`
	Id          int                       `json:"id"`
	Location    string                    `json:"location"`
	Name        string                    `json:"name"`
	TimeEnd     time.Time                 `json:"timeEnd"`
	TimeStart   time.Time                 `json:"timeStart"`
	Type        OfficialEventResponseType `json:"type"`
}

// OfficialEventResponseType defines model for OfficialEventResponse.Type.
type OfficialEventResponseType string

// OptionRequest defines model for OptionRequest.
type OptionRequest struct {
	Content string `json:"content"`

	// Id 選択肢ID（編集時のみ、新規作成時は不要）
	Id *int `json:"id,omitempty"`
}

// OptionResponse defines model for OptionResponse.
type OptionResponse struct {
	Content string `json:"content"`
	Id      int    `json:"id"`
}

// PaymentRequest defines model for PaymentRequest.
type PaymentRequest struct {
	Amount     int    `json:"amount"`
	AmountPaid int    `json:"amountPaid"`
	CampId     int    `json:"campId"`
	UserId     string `json:"userId"`
}

// PaymentResponse defines model for PaymentResponse.
type PaymentResponse struct {
	Amount     int    `json:"amount"`
	AmountPaid int    `json:"amountPaid"`
	CampId     int    `json:"campId"`
	Id         int    `json:"id"`
	UserId     string `json:"userId"`
}

// QuestionGroupMetadataRequest defines model for QuestionGroupMetadataRequest.
type QuestionGroupMetadataRequest struct {
	Description *string            `json:"description,omitempty"`
	Due         openapi_types.Date `json:"due"`
	Name        string             `json:"name"`
}

// QuestionGroupMetadataResponse defines model for QuestionGroupMetadataResponse.
type QuestionGroupMetadataResponse struct {
	Description *string            `json:"description,omitempty"`
	Due         openapi_types.Date `json:"due"`
	Id          int                `json:"id"`
	Name        string             `json:"name"`
}

// QuestionGroupRequest defines model for QuestionGroupRequest.
type QuestionGroupRequest struct {
	Description *string            `json:"description,omitempty"`
	Due         openapi_types.Date `json:"due"`
	Name        string             `json:"name"`
	Questions   []QuestionRequest  `json:"questions"`
}

// QuestionGroupResponse defines model for QuestionGroupResponse.
type QuestionGroupResponse struct {
	Description *string            `json:"description,omitempty"`
	Due         openapi_types.Date `json:"due"`
	Id          int                `json:"id"`
	Name        string             `json:"name"`
	Questions   []QuestionResponse `json:"questions"`
}

// QuestionRequest defines model for QuestionRequest.
type QuestionRequest struct {
	union json.RawMessage
}

// QuestionRequestBase defines model for QuestionRequestBase.
type QuestionRequestBase struct {
	Description *string `json:"description,omitempty"`
	IsOpen      bool    `json:"isOpen"`
	IsPublic    bool    `json:"isPublic"`
	Title       string  `json:"title"`
}

// QuestionResponse defines model for QuestionResponse.
type QuestionResponse struct {
	union json.RawMessage
}

// RollCallReactionRequest defines model for RollCallReactionRequest.
type RollCallReactionRequest struct {
	Content string `json:"content"`
}

// RollCallReactionResponse defines model for RollCallReactionResponse.
type RollCallReactionResponse struct {
	Content string `json:"content"`
	Id      int    `json:"id"`
	UserId  string `json:"userId"`
}

// RollCallRequest defines model for RollCallRequest.
type RollCallRequest struct {
	Description string   `json:"description"`
	Name        string   `json:"name"`
	Options     []string `json:"options"`
	Subjects    []string `json:"subjects"`
}

// RollCallResponse defines model for RollCallResponse.
type RollCallResponse struct {
	Description string   `json:"description"`
	Id          int      `json:"id"`
	Name        string   `json:"name"`
	Options     []string `json:"options"`
	Subjects    []string `json:"subjects"`
}

// RoomGroupRequest defines model for RoomGroupRequest.
type RoomGroupRequest struct {
	Name string `json:"name"`
}

// RoomGroupResponse defines model for RoomGroupResponse.
type RoomGroupResponse struct {
	Id    int            `json:"id"`
	Name  string         `json:"name"`
	Rooms []RoomResponse `json:"rooms"`
}

// RoomRequest defines model for RoomRequest.
type RoomRequest struct {
	MemberIds   []string `json:"memberIds"`
	Name        string   `json:"name"`
	RoomGroupId int      `json:"roomGroupId"`
}

// RoomResponse defines model for RoomResponse.
type RoomResponse struct {
	Id      int            `json:"id"`
	Members []UserResponse `json:"members"`
	Name    string         `json:"name"`
}

// SingleChoiceAnswerRequest defines model for SingleChoiceAnswerRequest.
type SingleChoiceAnswerRequest struct {
	OptionId   int                           `json:"optionId"`
	QuestionId int                           `json:"questionId"`
	Type       SingleChoiceAnswerRequestType `json:"type"`
}

// SingleChoiceAnswerRequestType defines model for SingleChoiceAnswerRequest.Type.
type SingleChoiceAnswerRequestType string

// SingleChoiceAnswerResponse defines model for SingleChoiceAnswerResponse.
type SingleChoiceAnswerResponse struct {
	Id             int                            `json:"id"`
	QuestionId     int                            `json:"questionId"`
	SelectedOption OptionResponse                 `json:"selectedOption"`
	Type           SingleChoiceAnswerResponseType `json:"type"`
	UserId         string                         `json:"userId"`
}

// SingleChoiceAnswerResponseType defines model for SingleChoiceAnswerResponse.Type.
type SingleChoiceAnswerResponseType string

// SingleChoiceQuestionRequest defines model for SingleChoiceQuestionRequest.
type SingleChoiceQuestionRequest struct {
	Description *string                         `json:"description,omitempty"`
	IsOpen      bool                            `json:"isOpen"`
	IsPublic    bool                            `json:"isPublic"`
	Options     []OptionRequest                 `json:"options"`
	Title       string                          `json:"title"`
	Type        SingleChoiceQuestionRequestType `json:"type"`
}

// SingleChoiceQuestionRequestType defines model for SingleChoiceQuestionRequest.Type.
type SingleChoiceQuestionRequestType string

// SingleChoiceQuestionResponse defines model for SingleChoiceQuestionResponse.
type SingleChoiceQuestionResponse struct {
	Description *string                          `json:"description"`
	Id          int                              `json:"id"`
	IsOpen      bool                             `json:"isOpen"`
	IsPublic    bool                             `json:"isPublic"`
	Options     []OptionResponse                 `json:"options"`
	Title       string                           `json:"title"`
	Type        SingleChoiceQuestionResponseType `json:"type"`
}

// SingleChoiceQuestionResponseType defines model for SingleChoiceQuestionResponse.Type.
type SingleChoiceQuestionResponseType string

// UserRequest defines model for UserRequest.
type UserRequest struct {
	IsStaff bool `json:"isStaff"`
}

// UserResponse defines model for UserResponse.
type UserResponse struct {
	Id      string `json:"id"`
	IsStaff bool   `json:"isStaff"`
}

// AnswerId defines model for AnswerId.
type AnswerId = int

// CampId defines model for CampId.
type CampId = int

// EventId defines model for EventId.
type EventId = int

// ImageId defines model for ImageId.
type ImageId = int

// OptionId defines model for OptionId.
type OptionId = int

// PaymentId defines model for PaymentId.
type PaymentId = int

// QuestionGroupId defines model for QuestionGroupId.
type QuestionGroupId = int

// QuestionId defines model for QuestionId.
type QuestionId = int

// ReactionId defines model for ReactionId.
type ReactionId = int

// RollCallId defines model for RollCallId.
type RollCallId = int

// RoomGroupId defines model for RoomGroupId.
type RoomGroupId = int

// RoomId defines model for RoomId.
type RoomId = int

// UserId defines model for UserId.
type UserId = string

// UserIdInQuery defines model for UserIdInQuery.
type UserIdInQuery = string

// XForwardedUser defines model for X-Forwarded-User.
type XForwardedUser = string

// BadRequest defines model for BadRequest.
type BadRequest struct {
	Message *string `json:"message,omitempty"`
}

// Conflict defines model for Conflict.
type Conflict struct {
	Message *string `json:"message,omitempty"`
}

// Forbidden defines model for Forbidden.
type Forbidden struct {
	Message *string `json:"message,omitempty"`
}

// InternalServerError defines model for InternalServerError.
type InternalServerError struct {
	Message *string `json:"message,omitempty"`
}

// NotFound defines model for NotFound.
type NotFound struct {
	Message *string `json:"message,omitempty"`
}

// AdminPutAnswerParams defines parameters for AdminPutAnswer.
type AdminPutAnswerParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPostCampParams defines parameters for AdminPostCamp.
type AdminPostCampParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminDeleteCampParams defines parameters for AdminDeleteCamp.
type AdminDeleteCampParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPutCampParams defines parameters for AdminPutCamp.
type AdminPutCampParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPostImageMultipartBody defines parameters for AdminPostImage.
type AdminPostImageMultipartBody struct {
	File *[]openapi_types.File `json:"file,omitempty"`
}

// AdminPostImageParams defines parameters for AdminPostImage.
type AdminPostImageParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminGetPaymentsParams defines parameters for AdminGetPayments.
type AdminGetPaymentsParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPostPaymentParams defines parameters for AdminPostPayment.
type AdminPostPaymentParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPostQuestionGroupParams defines parameters for AdminPostQuestionGroup.
type AdminPostQuestionGroupParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPostRollCallParams defines parameters for AdminPostRollCall.
type AdminPostRollCallParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPostRoomGroupParams defines parameters for AdminPostRoomGroup.
type AdminPostRoomGroupParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminDeleteImageParams defines parameters for AdminDeleteImage.
type AdminDeleteImageParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPutImageMultipartBody defines parameters for AdminPutImage.
type AdminPutImageMultipartBody struct {
	File *openapi_types.File `json:"file,omitempty"`
}

// AdminPutImageParams defines parameters for AdminPutImage.
type AdminPutImageParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminDeleteOptionParams defines parameters for AdminDeleteOption.
type AdminDeleteOptionParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPutOptionParams defines parameters for AdminPutOption.
type AdminPutOptionParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPutPaymentParams defines parameters for AdminPutPayment.
type AdminPutPaymentParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminDeleteQuestionGroupParams defines parameters for AdminDeleteQuestionGroup.
type AdminDeleteQuestionGroupParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPutQuestionGroupMetadataParams defines parameters for AdminPutQuestionGroupMetadata.
type AdminPutQuestionGroupMetadataParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminDeleteQuestionParams defines parameters for AdminDeleteQuestion.
type AdminDeleteQuestionParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPutQuestionParams defines parameters for AdminPutQuestion.
type AdminPutQuestionParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminGetAnswersParams defines parameters for AdminGetAnswers.
type AdminGetAnswersParams struct {
	// UserId User ID
	UserId *UserIdInQuery `form:"userId,omitempty" json:"userId,omitempty"`

	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminDeleteRoomGroupParams defines parameters for AdminDeleteRoomGroup.
type AdminDeleteRoomGroupParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPutRoomGroupParams defines parameters for AdminPutRoomGroup.
type AdminPutRoomGroupParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPostRoomParams defines parameters for AdminPostRoom.
type AdminPostRoomParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminDeleteRoomParams defines parameters for AdminDeleteRoom.
type AdminDeleteRoomParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPutRoomParams defines parameters for AdminPutRoom.
type AdminPutRoomParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminGetUserParams defines parameters for AdminGetUser.
type AdminGetUserParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPutUserParams defines parameters for AdminPutUser.
type AdminPutUserParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPostMessageParams defines parameters for AdminPostMessage.
type AdminPostMessageParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PutAnswerParams defines parameters for PutAnswer.
type PutAnswerParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PostEventParams defines parameters for PostEvent.
type PostEventParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// GetDashboardParams defines parameters for GetDashboard.
type GetDashboardParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// DeleteCampRegisterParams defines parameters for DeleteCampRegister.
type DeleteCampRegisterParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PostCampRegisterParams defines parameters for PostCampRegister.
type PostCampRegisterParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// DeleteEventParams defines parameters for DeleteEvent.
type DeleteEventParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PutEventParams defines parameters for PutEvent.
type PutEventParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// GetMeParams defines parameters for GetMe.
type GetMeParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// GetMyAnswersParams defines parameters for GetMyAnswers.
type GetMyAnswersParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PostAnswersJSONBody defines parameters for PostAnswers.
type PostAnswersJSONBody = []AnswerRequest

// PostAnswersParams defines parameters for PostAnswers.
type PostAnswersParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPostQuestionParams defines parameters for AdminPostQuestion.
type AdminPostQuestionParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// DeleteReactionParams defines parameters for DeleteReaction.
type DeleteReactionParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PutReactionParams defines parameters for PutReaction.
type PutReactionParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PostRollCallReactionParams defines parameters for PostRollCallReaction.
type PostRollCallReactionParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// AdminPutAnswerJSONRequestBody defines body for AdminPutAnswer for application/json ContentType.
type AdminPutAnswerJSONRequestBody = AnswerRequest

// AdminPostCampJSONRequestBody defines body for AdminPostCamp for application/json ContentType.
type AdminPostCampJSONRequestBody = CampRequest

// AdminPutCampJSONRequestBody defines body for AdminPutCamp for application/json ContentType.
type AdminPutCampJSONRequestBody = CampRequest

// AdminPostImageMultipartRequestBody defines body for AdminPostImage for multipart/form-data ContentType.
type AdminPostImageMultipartRequestBody AdminPostImageMultipartBody

// AdminPostPaymentJSONRequestBody defines body for AdminPostPayment for application/json ContentType.
type AdminPostPaymentJSONRequestBody = PaymentRequest

// AdminPostQuestionGroupJSONRequestBody defines body for AdminPostQuestionGroup for application/json ContentType.
type AdminPostQuestionGroupJSONRequestBody = QuestionGroupRequest

// AdminPostRollCallJSONRequestBody defines body for AdminPostRollCall for application/json ContentType.
type AdminPostRollCallJSONRequestBody = RollCallRequest

// AdminPostRoomGroupJSONRequestBody defines body for AdminPostRoomGroup for application/json ContentType.
type AdminPostRoomGroupJSONRequestBody = RoomGroupRequest

// AdminPutImageMultipartRequestBody defines body for AdminPutImage for multipart/form-data ContentType.
type AdminPutImageMultipartRequestBody AdminPutImageMultipartBody

// AdminPutOptionJSONRequestBody defines body for AdminPutOption for application/json ContentType.
type AdminPutOptionJSONRequestBody = OptionRequest

// AdminPutPaymentJSONRequestBody defines body for AdminPutPayment for application/json ContentType.
type AdminPutPaymentJSONRequestBody = PaymentRequest

// AdminPutQuestionGroupMetadataJSONRequestBody defines body for AdminPutQuestionGroupMetadata for application/json ContentType.
type AdminPutQuestionGroupMetadataJSONRequestBody = QuestionGroupMetadataRequest

// AdminPutQuestionJSONRequestBody defines body for AdminPutQuestion for application/json ContentType.
type AdminPutQuestionJSONRequestBody = QuestionRequest

// AdminPutRoomGroupJSONRequestBody defines body for AdminPutRoomGroup for application/json ContentType.
type AdminPutRoomGroupJSONRequestBody = RoomGroupRequest

// AdminPostRoomJSONRequestBody defines body for AdminPostRoom for application/json ContentType.
type AdminPostRoomJSONRequestBody = RoomRequest

// AdminPutRoomJSONRequestBody defines body for AdminPutRoom for application/json ContentType.
type AdminPutRoomJSONRequestBody = RoomRequest

// AdminPutUserJSONRequestBody defines body for AdminPutUser for application/json ContentType.
type AdminPutUserJSONRequestBody = UserRequest

// AdminPostMessageJSONRequestBody defines body for AdminPostMessage for application/json ContentType.
type AdminPostMessageJSONRequestBody = MessageRequest

// PutAnswerJSONRequestBody defines body for PutAnswer for application/json ContentType.
type PutAnswerJSONRequestBody = AnswerRequest

// PostEventJSONRequestBody defines body for PostEvent for application/json ContentType.
type PostEventJSONRequestBody = EventRequest

// PutEventJSONRequestBody defines body for PutEvent for application/json ContentType.
type PutEventJSONRequestBody = EventRequest

// PostAnswersJSONRequestBody defines body for PostAnswers for application/json ContentType.
type PostAnswersJSONRequestBody = PostAnswersJSONBody

// AdminPostQuestionJSONRequestBody defines body for AdminPostQuestion for application/json ContentType.
type AdminPostQuestionJSONRequestBody = QuestionRequest

// PutReactionJSONRequestBody defines body for PutReaction for application/json ContentType.
type PutReactionJSONRequestBody = RollCallReactionRequest

// PostRollCallReactionJSONRequestBody defines body for PostRollCallReaction for application/json ContentType.
type PostRollCallReactionJSONRequestBody = RollCallReactionRequest

// AsFreeTextAnswerRequest returns the union data inside the AnswerRequest as a FreeTextAnswerRequest
func (t AnswerRequest) AsFreeTextAnswerRequest() (FreeTextAnswerRequest, error) {
	var body FreeTextAnswerRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFreeTextAnswerRequest overwrites any union data inside the AnswerRequest as the provided FreeTextAnswerRequest
func (t *AnswerRequest) FromFreeTextAnswerRequest(v FreeTextAnswerRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFreeTextAnswerRequest performs a merge with any union data inside the AnswerRequest, using the provided FreeTextAnswerRequest
func (t *AnswerRequest) MergeFreeTextAnswerRequest(v FreeTextAnswerRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFreeNumberAnswerRequest returns the union data inside the AnswerRequest as a FreeNumberAnswerRequest
func (t AnswerRequest) AsFreeNumberAnswerRequest() (FreeNumberAnswerRequest, error) {
	var body FreeNumberAnswerRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFreeNumberAnswerRequest overwrites any union data inside the AnswerRequest as the provided FreeNumberAnswerRequest
func (t *AnswerRequest) FromFreeNumberAnswerRequest(v FreeNumberAnswerRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFreeNumberAnswerRequest performs a merge with any union data inside the AnswerRequest, using the provided FreeNumberAnswerRequest
func (t *AnswerRequest) MergeFreeNumberAnswerRequest(v FreeNumberAnswerRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSingleChoiceAnswerRequest returns the union data inside the AnswerRequest as a SingleChoiceAnswerRequest
func (t AnswerRequest) AsSingleChoiceAnswerRequest() (SingleChoiceAnswerRequest, error) {
	var body SingleChoiceAnswerRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSingleChoiceAnswerRequest overwrites any union data inside the AnswerRequest as the provided SingleChoiceAnswerRequest
func (t *AnswerRequest) FromSingleChoiceAnswerRequest(v SingleChoiceAnswerRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSingleChoiceAnswerRequest performs a merge with any union data inside the AnswerRequest, using the provided SingleChoiceAnswerRequest
func (t *AnswerRequest) MergeSingleChoiceAnswerRequest(v SingleChoiceAnswerRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultipleChoiceAnswerRequest returns the union data inside the AnswerRequest as a MultipleChoiceAnswerRequest
func (t AnswerRequest) AsMultipleChoiceAnswerRequest() (MultipleChoiceAnswerRequest, error) {
	var body MultipleChoiceAnswerRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultipleChoiceAnswerRequest overwrites any union data inside the AnswerRequest as the provided MultipleChoiceAnswerRequest
func (t *AnswerRequest) FromMultipleChoiceAnswerRequest(v MultipleChoiceAnswerRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultipleChoiceAnswerRequest performs a merge with any union data inside the AnswerRequest, using the provided MultipleChoiceAnswerRequest
func (t *AnswerRequest) MergeMultipleChoiceAnswerRequest(v MultipleChoiceAnswerRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AnswerRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AnswerRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFreeTextAnswerResponse returns the union data inside the AnswerResponse as a FreeTextAnswerResponse
func (t AnswerResponse) AsFreeTextAnswerResponse() (FreeTextAnswerResponse, error) {
	var body FreeTextAnswerResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFreeTextAnswerResponse overwrites any union data inside the AnswerResponse as the provided FreeTextAnswerResponse
func (t *AnswerResponse) FromFreeTextAnswerResponse(v FreeTextAnswerResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFreeTextAnswerResponse performs a merge with any union data inside the AnswerResponse, using the provided FreeTextAnswerResponse
func (t *AnswerResponse) MergeFreeTextAnswerResponse(v FreeTextAnswerResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFreeNumberAnswerResponse returns the union data inside the AnswerResponse as a FreeNumberAnswerResponse
func (t AnswerResponse) AsFreeNumberAnswerResponse() (FreeNumberAnswerResponse, error) {
	var body FreeNumberAnswerResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFreeNumberAnswerResponse overwrites any union data inside the AnswerResponse as the provided FreeNumberAnswerResponse
func (t *AnswerResponse) FromFreeNumberAnswerResponse(v FreeNumberAnswerResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFreeNumberAnswerResponse performs a merge with any union data inside the AnswerResponse, using the provided FreeNumberAnswerResponse
func (t *AnswerResponse) MergeFreeNumberAnswerResponse(v FreeNumberAnswerResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSingleChoiceAnswerResponse returns the union data inside the AnswerResponse as a SingleChoiceAnswerResponse
func (t AnswerResponse) AsSingleChoiceAnswerResponse() (SingleChoiceAnswerResponse, error) {
	var body SingleChoiceAnswerResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSingleChoiceAnswerResponse overwrites any union data inside the AnswerResponse as the provided SingleChoiceAnswerResponse
func (t *AnswerResponse) FromSingleChoiceAnswerResponse(v SingleChoiceAnswerResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSingleChoiceAnswerResponse performs a merge with any union data inside the AnswerResponse, using the provided SingleChoiceAnswerResponse
func (t *AnswerResponse) MergeSingleChoiceAnswerResponse(v SingleChoiceAnswerResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultipleChoiceAnswerResponse returns the union data inside the AnswerResponse as a MultipleChoiceAnswerResponse
func (t AnswerResponse) AsMultipleChoiceAnswerResponse() (MultipleChoiceAnswerResponse, error) {
	var body MultipleChoiceAnswerResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultipleChoiceAnswerResponse overwrites any union data inside the AnswerResponse as the provided MultipleChoiceAnswerResponse
func (t *AnswerResponse) FromMultipleChoiceAnswerResponse(v MultipleChoiceAnswerResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultipleChoiceAnswerResponse performs a merge with any union data inside the AnswerResponse, using the provided MultipleChoiceAnswerResponse
func (t *AnswerResponse) MergeMultipleChoiceAnswerResponse(v MultipleChoiceAnswerResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AnswerResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AnswerResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDurationEventRequest returns the union data inside the EventRequest as a DurationEventRequest
func (t EventRequest) AsDurationEventRequest() (DurationEventRequest, error) {
	var body DurationEventRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDurationEventRequest overwrites any union data inside the EventRequest as the provided DurationEventRequest
func (t *EventRequest) FromDurationEventRequest(v DurationEventRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDurationEventRequest performs a merge with any union data inside the EventRequest, using the provided DurationEventRequest
func (t *EventRequest) MergeDurationEventRequest(v DurationEventRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOfficialEventRequest returns the union data inside the EventRequest as a OfficialEventRequest
func (t EventRequest) AsOfficialEventRequest() (OfficialEventRequest, error) {
	var body OfficialEventRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOfficialEventRequest overwrites any union data inside the EventRequest as the provided OfficialEventRequest
func (t *EventRequest) FromOfficialEventRequest(v OfficialEventRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOfficialEventRequest performs a merge with any union data inside the EventRequest, using the provided OfficialEventRequest
func (t *EventRequest) MergeOfficialEventRequest(v OfficialEventRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMomentEventRequest returns the union data inside the EventRequest as a MomentEventRequest
func (t EventRequest) AsMomentEventRequest() (MomentEventRequest, error) {
	var body MomentEventRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMomentEventRequest overwrites any union data inside the EventRequest as the provided MomentEventRequest
func (t *EventRequest) FromMomentEventRequest(v MomentEventRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMomentEventRequest performs a merge with any union data inside the EventRequest, using the provided MomentEventRequest
func (t *EventRequest) MergeMomentEventRequest(v MomentEventRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EventRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EventRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDurationEventResponse returns the union data inside the EventResponse as a DurationEventResponse
func (t EventResponse) AsDurationEventResponse() (DurationEventResponse, error) {
	var body DurationEventResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDurationEventResponse overwrites any union data inside the EventResponse as the provided DurationEventResponse
func (t *EventResponse) FromDurationEventResponse(v DurationEventResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDurationEventResponse performs a merge with any union data inside the EventResponse, using the provided DurationEventResponse
func (t *EventResponse) MergeDurationEventResponse(v DurationEventResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOfficialEventResponse returns the union data inside the EventResponse as a OfficialEventResponse
func (t EventResponse) AsOfficialEventResponse() (OfficialEventResponse, error) {
	var body OfficialEventResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOfficialEventResponse overwrites any union data inside the EventResponse as the provided OfficialEventResponse
func (t *EventResponse) FromOfficialEventResponse(v OfficialEventResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOfficialEventResponse performs a merge with any union data inside the EventResponse, using the provided OfficialEventResponse
func (t *EventResponse) MergeOfficialEventResponse(v OfficialEventResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMomentEventResponse returns the union data inside the EventResponse as a MomentEventResponse
func (t EventResponse) AsMomentEventResponse() (MomentEventResponse, error) {
	var body MomentEventResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMomentEventResponse overwrites any union data inside the EventResponse as the provided MomentEventResponse
func (t *EventResponse) FromMomentEventResponse(v MomentEventResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMomentEventResponse performs a merge with any union data inside the EventResponse, using the provided MomentEventResponse
func (t *EventResponse) MergeMomentEventResponse(v MomentEventResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EventResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EventResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFreeTextQuestionRequest returns the union data inside the QuestionRequest as a FreeTextQuestionRequest
func (t QuestionRequest) AsFreeTextQuestionRequest() (FreeTextQuestionRequest, error) {
	var body FreeTextQuestionRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFreeTextQuestionRequest overwrites any union data inside the QuestionRequest as the provided FreeTextQuestionRequest
func (t *QuestionRequest) FromFreeTextQuestionRequest(v FreeTextQuestionRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFreeTextQuestionRequest performs a merge with any union data inside the QuestionRequest, using the provided FreeTextQuestionRequest
func (t *QuestionRequest) MergeFreeTextQuestionRequest(v FreeTextQuestionRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFreeNumberQuestionRequest returns the union data inside the QuestionRequest as a FreeNumberQuestionRequest
func (t QuestionRequest) AsFreeNumberQuestionRequest() (FreeNumberQuestionRequest, error) {
	var body FreeNumberQuestionRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFreeNumberQuestionRequest overwrites any union data inside the QuestionRequest as the provided FreeNumberQuestionRequest
func (t *QuestionRequest) FromFreeNumberQuestionRequest(v FreeNumberQuestionRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFreeNumberQuestionRequest performs a merge with any union data inside the QuestionRequest, using the provided FreeNumberQuestionRequest
func (t *QuestionRequest) MergeFreeNumberQuestionRequest(v FreeNumberQuestionRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSingleChoiceQuestionRequest returns the union data inside the QuestionRequest as a SingleChoiceQuestionRequest
func (t QuestionRequest) AsSingleChoiceQuestionRequest() (SingleChoiceQuestionRequest, error) {
	var body SingleChoiceQuestionRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSingleChoiceQuestionRequest overwrites any union data inside the QuestionRequest as the provided SingleChoiceQuestionRequest
func (t *QuestionRequest) FromSingleChoiceQuestionRequest(v SingleChoiceQuestionRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSingleChoiceQuestionRequest performs a merge with any union data inside the QuestionRequest, using the provided SingleChoiceQuestionRequest
func (t *QuestionRequest) MergeSingleChoiceQuestionRequest(v SingleChoiceQuestionRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultipleChoiceQuestionRequest returns the union data inside the QuestionRequest as a MultipleChoiceQuestionRequest
func (t QuestionRequest) AsMultipleChoiceQuestionRequest() (MultipleChoiceQuestionRequest, error) {
	var body MultipleChoiceQuestionRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultipleChoiceQuestionRequest overwrites any union data inside the QuestionRequest as the provided MultipleChoiceQuestionRequest
func (t *QuestionRequest) FromMultipleChoiceQuestionRequest(v MultipleChoiceQuestionRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultipleChoiceQuestionRequest performs a merge with any union data inside the QuestionRequest, using the provided MultipleChoiceQuestionRequest
func (t *QuestionRequest) MergeMultipleChoiceQuestionRequest(v MultipleChoiceQuestionRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t QuestionRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *QuestionRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFreeTextQuestionResponse returns the union data inside the QuestionResponse as a FreeTextQuestionResponse
func (t QuestionResponse) AsFreeTextQuestionResponse() (FreeTextQuestionResponse, error) {
	var body FreeTextQuestionResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFreeTextQuestionResponse overwrites any union data inside the QuestionResponse as the provided FreeTextQuestionResponse
func (t *QuestionResponse) FromFreeTextQuestionResponse(v FreeTextQuestionResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFreeTextQuestionResponse performs a merge with any union data inside the QuestionResponse, using the provided FreeTextQuestionResponse
func (t *QuestionResponse) MergeFreeTextQuestionResponse(v FreeTextQuestionResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFreeNumberQuestionResponse returns the union data inside the QuestionResponse as a FreeNumberQuestionResponse
func (t QuestionResponse) AsFreeNumberQuestionResponse() (FreeNumberQuestionResponse, error) {
	var body FreeNumberQuestionResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFreeNumberQuestionResponse overwrites any union data inside the QuestionResponse as the provided FreeNumberQuestionResponse
func (t *QuestionResponse) FromFreeNumberQuestionResponse(v FreeNumberQuestionResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFreeNumberQuestionResponse performs a merge with any union data inside the QuestionResponse, using the provided FreeNumberQuestionResponse
func (t *QuestionResponse) MergeFreeNumberQuestionResponse(v FreeNumberQuestionResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSingleChoiceQuestionResponse returns the union data inside the QuestionResponse as a SingleChoiceQuestionResponse
func (t QuestionResponse) AsSingleChoiceQuestionResponse() (SingleChoiceQuestionResponse, error) {
	var body SingleChoiceQuestionResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSingleChoiceQuestionResponse overwrites any union data inside the QuestionResponse as the provided SingleChoiceQuestionResponse
func (t *QuestionResponse) FromSingleChoiceQuestionResponse(v SingleChoiceQuestionResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSingleChoiceQuestionResponse performs a merge with any union data inside the QuestionResponse, using the provided SingleChoiceQuestionResponse
func (t *QuestionResponse) MergeSingleChoiceQuestionResponse(v SingleChoiceQuestionResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultipleChoiceQuestionResponse returns the union data inside the QuestionResponse as a MultipleChoiceQuestionResponse
func (t QuestionResponse) AsMultipleChoiceQuestionResponse() (MultipleChoiceQuestionResponse, error) {
	var body MultipleChoiceQuestionResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultipleChoiceQuestionResponse overwrites any union data inside the QuestionResponse as the provided MultipleChoiceQuestionResponse
func (t *QuestionResponse) FromMultipleChoiceQuestionResponse(v MultipleChoiceQuestionResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultipleChoiceQuestionResponse performs a merge with any union data inside the QuestionResponse, using the provided MultipleChoiceQuestionResponse
func (t *QuestionResponse) MergeMultipleChoiceQuestionResponse(v MultipleChoiceQuestionResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t QuestionResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *QuestionResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 管理者が回答を更新
	// (PUT /api/admin/answers/{answerId})
	AdminPutAnswer(ctx echo.Context, answerId AnswerId, params AdminPutAnswerParams) error
	// 合宿を作成（管理者用）
	// (POST /api/admin/camps)
	AdminPostCamp(ctx echo.Context, params AdminPostCampParams) error
	// 合宿を削除（管理者用）
	// (DELETE /api/admin/camps/{campId})
	AdminDeleteCamp(ctx echo.Context, campId CampId, params AdminDeleteCampParams) error
	// 合宿を更新（管理者用）
	// (PUT /api/admin/camps/{campId})
	AdminPutCamp(ctx echo.Context, campId CampId, params AdminPutCampParams) error
	// 画像をアップロード（管理者用）
	// (POST /api/admin/camps/{campId}/images)
	AdminPostImage(ctx echo.Context, campId CampId, params AdminPostImageParams) error
	// 支払い情報の一覧を取得（管理者用）
	// (GET /api/admin/camps/{campId}/payments)
	AdminGetPayments(ctx echo.Context, campId CampId, params AdminGetPaymentsParams) error
	// 支払い情報を作成（管理者用）
	// (POST /api/admin/camps/{campId}/payments)
	AdminPostPayment(ctx echo.Context, campId CampId, params AdminPostPaymentParams) error
	// 質問グループを作成（管理者用）
	// (POST /api/admin/camps/{campId}/question-groups)
	AdminPostQuestionGroup(ctx echo.Context, campId CampId, params AdminPostQuestionGroupParams) error
	// 点呼を作成（管理者用）
	// (POST /api/admin/camps/{campId}/roll-calls)
	AdminPostRollCall(ctx echo.Context, campId CampId, params AdminPostRollCallParams) error
	// 部屋グループを作成（管理者用）
	// (POST /api/admin/camps/{campId}/room-groups)
	AdminPostRoomGroup(ctx echo.Context, campId CampId, params AdminPostRoomGroupParams) error
	// 画像を削除（管理者用）
	// (DELETE /api/admin/images/{imageId})
	AdminDeleteImage(ctx echo.Context, imageId ImageId, params AdminDeleteImageParams) error
	// 画像を更新（管理者用）
	// (PUT /api/admin/images/{imageId})
	AdminPutImage(ctx echo.Context, imageId ImageId, params AdminPutImageParams) error
	// 選択肢を削除（管理者用）
	// (DELETE /api/admin/options/{optionId})
	AdminDeleteOption(ctx echo.Context, optionId OptionId, params AdminDeleteOptionParams) error
	// 選択肢を更新（管理者用）
	// (PUT /api/admin/options/{optionId})
	AdminPutOption(ctx echo.Context, optionId OptionId, params AdminPutOptionParams) error
	// 支払い情報を更新（管理者用）
	// (PUT /api/admin/payments/{paymentId})
	AdminPutPayment(ctx echo.Context, paymentId PaymentId, params AdminPutPaymentParams) error
	// 質問グループを削除（管理者用）
	// (DELETE /api/admin/question-groups/{questionGroupId})
	AdminDeleteQuestionGroup(ctx echo.Context, questionGroupId QuestionGroupId, params AdminDeleteQuestionGroupParams) error
	// 質問グループを更新（管理者用）
	// (PUT /api/admin/question-groups/{questionGroupId})
	AdminPutQuestionGroupMetadata(ctx echo.Context, questionGroupId QuestionGroupId, params AdminPutQuestionGroupMetadataParams) error
	// 質問を削除（管理者用）
	// (DELETE /api/admin/questions/{questionId})
	AdminDeleteQuestion(ctx echo.Context, questionId QuestionId, params AdminDeleteQuestionParams) error
	// 質問を更新（管理者用）
	// (PUT /api/admin/questions/{questionId})
	AdminPutQuestion(ctx echo.Context, questionId QuestionId, params AdminPutQuestionParams) error
	// 質問の回答を取得（管理者用）
	// (GET /api/admin/questions/{questionId}/answers)
	AdminGetAnswers(ctx echo.Context, questionId QuestionId, params AdminGetAnswersParams) error
	// 部屋グループを削除（管理者用）
	// (DELETE /api/admin/room-groups/{roomGroupId})
	AdminDeleteRoomGroup(ctx echo.Context, roomGroupId RoomGroupId, params AdminDeleteRoomGroupParams) error
	// 部屋グループを更新（管理者用）
	// (PUT /api/admin/room-groups/{roomGroupId})
	AdminPutRoomGroup(ctx echo.Context, roomGroupId RoomGroupId, params AdminPutRoomGroupParams) error
	// 部屋を作成（管理者用）
	// (POST /api/admin/rooms)
	AdminPostRoom(ctx echo.Context, params AdminPostRoomParams) error
	// 部屋を削除（管理者用）
	// (DELETE /api/admin/rooms/{roomId})
	AdminDeleteRoom(ctx echo.Context, roomId RoomId, params AdminDeleteRoomParams) error
	// 部屋を更新（管理者用）
	// (PUT /api/admin/rooms/{roomId})
	AdminPutRoom(ctx echo.Context, roomId RoomId, params AdminPutRoomParams) error
	// ユーザー情報を取得（管理者用）
	// (GET /api/admin/users/{userId})
	AdminGetUser(ctx echo.Context, userId UserId, params AdminGetUserParams) error
	// ユーザーの情報を更新（主に合宿係の権限管理用）
	// (PUT /api/admin/users/{userId})
	AdminPutUser(ctx echo.Context, userId UserId, params AdminPutUserParams) error
	// ユーザーにDMを送信（管理者用）
	// (POST /api/admin/users/{userId}/messages)
	AdminPostMessage(ctx echo.Context, userId UserId, params AdminPostMessageParams) error
	// 自分の回答を更新
	// (PUT /api/answers/{answerId})
	PutAnswer(ctx echo.Context, answerId AnswerId, params PutAnswerParams) error
	// 合宿の一覧を取得
	// (GET /api/camps)
	GetCamps(ctx echo.Context) error
	// イベントの一覧を取得
	// (GET /api/camps/{campId}/events)
	GetEvents(ctx echo.Context, campId CampId) error
	// イベントを作成
	// (POST /api/camps/{campId}/events)
	PostEvent(ctx echo.Context, campId CampId, params PostEventParams) error
	// 画像の一覧を取得
	// (GET /api/camps/{campId}/images)
	GetImages(ctx echo.Context, campId CampId) error
	// 自分の合宿参加情報を取得
	// (GET /api/camps/{campId}/me)
	GetDashboard(ctx echo.Context, campId CampId, params GetDashboardParams) error
	// 合宿の参加者一覧を取得
	// (GET /api/camps/{campId}/participants)
	GetCampParticipants(ctx echo.Context, campId CampId) error
	// 質問グループの一覧を取得
	// (GET /api/camps/{campId}/question-groups)
	GetQuestionGroups(ctx echo.Context, campId CampId) error
	// 合宿の参加登録を解除
	// (DELETE /api/camps/{campId}/register)
	DeleteCampRegister(ctx echo.Context, campId CampId, params DeleteCampRegisterParams) error
	// 合宿に参加登録
	// (POST /api/camps/{campId}/register)
	PostCampRegister(ctx echo.Context, campId CampId, params PostCampRegisterParams) error
	// 点呼の一覧を取得
	// (GET /api/camps/{campId}/roll-calls)
	GetRollCalls(ctx echo.Context, campId CampId) error
	// 部屋グループの一覧を取得
	// (GET /api/camps/{campId}/room-groups)
	GetRoomGroups(ctx echo.Context, campId CampId) error
	// イベントを削除
	// (DELETE /api/events/{eventId})
	DeleteEvent(ctx echo.Context, eventId EventId, params DeleteEventParams) error
	// イベントを更新
	// (PUT /api/events/{eventId})
	PutEvent(ctx echo.Context, eventId EventId, params PutEventParams) error
	// 画像を取得
	// (GET /api/images/{imageId})
	GetImage(ctx echo.Context, imageId ImageId) error
	// 自分の情報を取得
	// (GET /api/me)
	GetMe(ctx echo.Context, params GetMeParams) error
	// ある質問グループに対する自分の回答を取得
	// (GET /api/me/question-groups/{questionGroupId}/answers)
	GetMyAnswers(ctx echo.Context, questionGroupId QuestionGroupId, params GetMyAnswersParams) error
	// 質問に回答する
	// (POST /api/question-groups/{questionGroupId}/answers)
	PostAnswers(ctx echo.Context, questionGroupId QuestionGroupId, params PostAnswersParams) error
	// 質問を追加
	// (POST /api/question-groups/{questionGroupId}/questions)
	AdminPostQuestion(ctx echo.Context, questionGroupId QuestionGroupId, params AdminPostQuestionParams) error
	// 質問の回答一覧を取得
	// (GET /api/questions/{questionId}/answers)
	GetAnswers(ctx echo.Context, questionId QuestionId) error
	// リアクションを削除
	// (DELETE /api/reactions/{reactionId})
	DeleteReaction(ctx echo.Context, reactionId ReactionId, params DeleteReactionParams) error
	// リアクションを更新
	// (PUT /api/reactions/{reactionId})
	PutReaction(ctx echo.Context, reactionId ReactionId, params PutReactionParams) error
	// 点呼のリアクション一覧を取得
	// (GET /api/roll-calls/{rollCallId}/reactions)
	GetRollCallReactions(ctx echo.Context, rollCallId RollCallId) error
	// 点呼にリアクションを追加
	// (POST /api/roll-calls/{rollCallId}/reactions)
	PostRollCallReaction(ctx echo.Context, rollCallId RollCallId, params PostRollCallReactionParams) error
	// 新たに作成されたリアクションをストリームで取得
	// (GET /api/roll-calls/{rollCallId}/reactions/stream)
	StreamRollCallReactions(ctx echo.Context, rollCallId RollCallId) error
	// 合宿係の一覧を取得
	// (GET /api/staffs)
	GetStaffs(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AdminPutAnswer converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPutAnswer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "answerId" -------------
	var answerId AnswerId

	err = runtime.BindStyledParameterWithOptions("simple", "answerId", ctx.Param("answerId"), &answerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter answerId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPutAnswerParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPutAnswer(ctx, answerId, params)
	return err
}

// AdminPostCamp converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPostCamp(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPostCampParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPostCamp(ctx, params)
	return err
}

// AdminDeleteCamp converts echo context to params.
func (w *ServerInterfaceWrapper) AdminDeleteCamp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminDeleteCampParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminDeleteCamp(ctx, campId, params)
	return err
}

// AdminPutCamp converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPutCamp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPutCampParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPutCamp(ctx, campId, params)
	return err
}

// AdminPostImage converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPostImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPostImageParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPostImage(ctx, campId, params)
	return err
}

// AdminGetPayments converts echo context to params.
func (w *ServerInterfaceWrapper) AdminGetPayments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminGetPaymentsParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminGetPayments(ctx, campId, params)
	return err
}

// AdminPostPayment converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPostPayment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPostPaymentParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPostPayment(ctx, campId, params)
	return err
}

// AdminPostQuestionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPostQuestionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPostQuestionGroupParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPostQuestionGroup(ctx, campId, params)
	return err
}

// AdminPostRollCall converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPostRollCall(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPostRollCallParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPostRollCall(ctx, campId, params)
	return err
}

// AdminPostRoomGroup converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPostRoomGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPostRoomGroupParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPostRoomGroup(ctx, campId, params)
	return err
}

// AdminDeleteImage converts echo context to params.
func (w *ServerInterfaceWrapper) AdminDeleteImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "imageId" -------------
	var imageId ImageId

	err = runtime.BindStyledParameterWithOptions("simple", "imageId", ctx.Param("imageId"), &imageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter imageId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminDeleteImageParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminDeleteImage(ctx, imageId, params)
	return err
}

// AdminPutImage converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPutImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "imageId" -------------
	var imageId ImageId

	err = runtime.BindStyledParameterWithOptions("simple", "imageId", ctx.Param("imageId"), &imageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter imageId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPutImageParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPutImage(ctx, imageId, params)
	return err
}

// AdminDeleteOption converts echo context to params.
func (w *ServerInterfaceWrapper) AdminDeleteOption(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "optionId" -------------
	var optionId OptionId

	err = runtime.BindStyledParameterWithOptions("simple", "optionId", ctx.Param("optionId"), &optionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter optionId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminDeleteOptionParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminDeleteOption(ctx, optionId, params)
	return err
}

// AdminPutOption converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPutOption(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "optionId" -------------
	var optionId OptionId

	err = runtime.BindStyledParameterWithOptions("simple", "optionId", ctx.Param("optionId"), &optionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter optionId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPutOptionParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPutOption(ctx, optionId, params)
	return err
}

// AdminPutPayment converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPutPayment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "paymentId" -------------
	var paymentId PaymentId

	err = runtime.BindStyledParameterWithOptions("simple", "paymentId", ctx.Param("paymentId"), &paymentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter paymentId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPutPaymentParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPutPayment(ctx, paymentId, params)
	return err
}

// AdminDeleteQuestionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) AdminDeleteQuestionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "questionGroupId" -------------
	var questionGroupId QuestionGroupId

	err = runtime.BindStyledParameterWithOptions("simple", "questionGroupId", ctx.Param("questionGroupId"), &questionGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter questionGroupId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminDeleteQuestionGroupParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminDeleteQuestionGroup(ctx, questionGroupId, params)
	return err
}

// AdminPutQuestionGroupMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPutQuestionGroupMetadata(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "questionGroupId" -------------
	var questionGroupId QuestionGroupId

	err = runtime.BindStyledParameterWithOptions("simple", "questionGroupId", ctx.Param("questionGroupId"), &questionGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter questionGroupId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPutQuestionGroupMetadataParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPutQuestionGroupMetadata(ctx, questionGroupId, params)
	return err
}

// AdminDeleteQuestion converts echo context to params.
func (w *ServerInterfaceWrapper) AdminDeleteQuestion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "questionId" -------------
	var questionId QuestionId

	err = runtime.BindStyledParameterWithOptions("simple", "questionId", ctx.Param("questionId"), &questionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter questionId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminDeleteQuestionParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminDeleteQuestion(ctx, questionId, params)
	return err
}

// AdminPutQuestion converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPutQuestion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "questionId" -------------
	var questionId QuestionId

	err = runtime.BindStyledParameterWithOptions("simple", "questionId", ctx.Param("questionId"), &questionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter questionId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPutQuestionParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPutQuestion(ctx, questionId, params)
	return err
}

// AdminGetAnswers converts echo context to params.
func (w *ServerInterfaceWrapper) AdminGetAnswers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "questionId" -------------
	var questionId QuestionId

	err = runtime.BindStyledParameterWithOptions("simple", "questionId", ctx.Param("questionId"), &questionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter questionId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminGetAnswersParams
	// ------------- Optional query parameter "userId" -------------

	err = runtime.BindQueryParameter("form", true, false, "userId", ctx.QueryParams(), &params.UserId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminGetAnswers(ctx, questionId, params)
	return err
}

// AdminDeleteRoomGroup converts echo context to params.
func (w *ServerInterfaceWrapper) AdminDeleteRoomGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "roomGroupId" -------------
	var roomGroupId RoomGroupId

	err = runtime.BindStyledParameterWithOptions("simple", "roomGroupId", ctx.Param("roomGroupId"), &roomGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter roomGroupId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminDeleteRoomGroupParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminDeleteRoomGroup(ctx, roomGroupId, params)
	return err
}

// AdminPutRoomGroup converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPutRoomGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "roomGroupId" -------------
	var roomGroupId RoomGroupId

	err = runtime.BindStyledParameterWithOptions("simple", "roomGroupId", ctx.Param("roomGroupId"), &roomGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter roomGroupId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPutRoomGroupParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPutRoomGroup(ctx, roomGroupId, params)
	return err
}

// AdminPostRoom converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPostRoom(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPostRoomParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPostRoom(ctx, params)
	return err
}

// AdminDeleteRoom converts echo context to params.
func (w *ServerInterfaceWrapper) AdminDeleteRoom(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "roomId" -------------
	var roomId RoomId

	err = runtime.BindStyledParameterWithOptions("simple", "roomId", ctx.Param("roomId"), &roomId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter roomId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminDeleteRoomParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminDeleteRoom(ctx, roomId, params)
	return err
}

// AdminPutRoom converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPutRoom(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "roomId" -------------
	var roomId RoomId

	err = runtime.BindStyledParameterWithOptions("simple", "roomId", ctx.Param("roomId"), &roomId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter roomId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPutRoomParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPutRoom(ctx, roomId, params)
	return err
}

// AdminGetUser converts echo context to params.
func (w *ServerInterfaceWrapper) AdminGetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", ctx.Param("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminGetUserParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminGetUser(ctx, userId, params)
	return err
}

// AdminPutUser converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPutUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", ctx.Param("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPutUserParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPutUser(ctx, userId, params)
	return err
}

// AdminPostMessage converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPostMessage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", ctx.Param("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPostMessageParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPostMessage(ctx, userId, params)
	return err
}

// PutAnswer converts echo context to params.
func (w *ServerInterfaceWrapper) PutAnswer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "answerId" -------------
	var answerId AnswerId

	err = runtime.BindStyledParameterWithOptions("simple", "answerId", ctx.Param("answerId"), &answerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter answerId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAnswerParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAnswer(ctx, answerId, params)
	return err
}

// GetCamps converts echo context to params.
func (w *ServerInterfaceWrapper) GetCamps(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCamps(ctx)
	return err
}

// GetEvents converts echo context to params.
func (w *ServerInterfaceWrapper) GetEvents(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEvents(ctx, campId)
	return err
}

// PostEvent converts echo context to params.
func (w *ServerInterfaceWrapper) PostEvent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PostEventParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEvent(ctx, campId, params)
	return err
}

// GetImages converts echo context to params.
func (w *ServerInterfaceWrapper) GetImages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetImages(ctx, campId)
	return err
}

// GetDashboard converts echo context to params.
func (w *ServerInterfaceWrapper) GetDashboard(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDashboardParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDashboard(ctx, campId, params)
	return err
}

// GetCampParticipants converts echo context to params.
func (w *ServerInterfaceWrapper) GetCampParticipants(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCampParticipants(ctx, campId)
	return err
}

// GetQuestionGroups converts echo context to params.
func (w *ServerInterfaceWrapper) GetQuestionGroups(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetQuestionGroups(ctx, campId)
	return err
}

// DeleteCampRegister converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCampRegister(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteCampRegisterParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteCampRegister(ctx, campId, params)
	return err
}

// PostCampRegister converts echo context to params.
func (w *ServerInterfaceWrapper) PostCampRegister(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PostCampRegisterParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostCampRegister(ctx, campId, params)
	return err
}

// GetRollCalls converts echo context to params.
func (w *ServerInterfaceWrapper) GetRollCalls(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRollCalls(ctx, campId)
	return err
}

// GetRoomGroups converts echo context to params.
func (w *ServerInterfaceWrapper) GetRoomGroups(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "campId" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "campId", ctx.Param("campId"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter campId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRoomGroups(ctx, campId)
	return err
}

// DeleteEvent converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEvent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "eventId" -------------
	var eventId EventId

	err = runtime.BindStyledParameterWithOptions("simple", "eventId", ctx.Param("eventId"), &eventId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter eventId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteEventParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEvent(ctx, eventId, params)
	return err
}

// PutEvent converts echo context to params.
func (w *ServerInterfaceWrapper) PutEvent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "eventId" -------------
	var eventId EventId

	err = runtime.BindStyledParameterWithOptions("simple", "eventId", ctx.Param("eventId"), &eventId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter eventId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutEventParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutEvent(ctx, eventId, params)
	return err
}

// GetImage converts echo context to params.
func (w *ServerInterfaceWrapper) GetImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "imageId" -------------
	var imageId ImageId

	err = runtime.BindStyledParameterWithOptions("simple", "imageId", ctx.Param("imageId"), &imageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter imageId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetImage(ctx, imageId)
	return err
}

// GetMe converts echo context to params.
func (w *ServerInterfaceWrapper) GetMe(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMeParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMe(ctx, params)
	return err
}

// GetMyAnswers converts echo context to params.
func (w *ServerInterfaceWrapper) GetMyAnswers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "questionGroupId" -------------
	var questionGroupId QuestionGroupId

	err = runtime.BindStyledParameterWithOptions("simple", "questionGroupId", ctx.Param("questionGroupId"), &questionGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter questionGroupId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMyAnswersParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMyAnswers(ctx, questionGroupId, params)
	return err
}

// PostAnswers converts echo context to params.
func (w *ServerInterfaceWrapper) PostAnswers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "questionGroupId" -------------
	var questionGroupId QuestionGroupId

	err = runtime.BindStyledParameterWithOptions("simple", "questionGroupId", ctx.Param("questionGroupId"), &questionGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter questionGroupId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAnswersParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAnswers(ctx, questionGroupId, params)
	return err
}

// AdminPostQuestion converts echo context to params.
func (w *ServerInterfaceWrapper) AdminPostQuestion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "questionGroupId" -------------
	var questionGroupId QuestionGroupId

	err = runtime.BindStyledParameterWithOptions("simple", "questionGroupId", ctx.Param("questionGroupId"), &questionGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter questionGroupId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminPostQuestionParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminPostQuestion(ctx, questionGroupId, params)
	return err
}

// GetAnswers converts echo context to params.
func (w *ServerInterfaceWrapper) GetAnswers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "questionId" -------------
	var questionId QuestionId

	err = runtime.BindStyledParameterWithOptions("simple", "questionId", ctx.Param("questionId"), &questionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter questionId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAnswers(ctx, questionId)
	return err
}

// DeleteReaction converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteReaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reactionId" -------------
	var reactionId ReactionId

	err = runtime.BindStyledParameterWithOptions("simple", "reactionId", ctx.Param("reactionId"), &reactionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reactionId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteReactionParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteReaction(ctx, reactionId, params)
	return err
}

// PutReaction converts echo context to params.
func (w *ServerInterfaceWrapper) PutReaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reactionId" -------------
	var reactionId ReactionId

	err = runtime.BindStyledParameterWithOptions("simple", "reactionId", ctx.Param("reactionId"), &reactionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reactionId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutReactionParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutReaction(ctx, reactionId, params)
	return err
}

// GetRollCallReactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetRollCallReactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "rollCallId" -------------
	var rollCallId RollCallId

	err = runtime.BindStyledParameterWithOptions("simple", "rollCallId", ctx.Param("rollCallId"), &rollCallId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rollCallId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRollCallReactions(ctx, rollCallId)
	return err
}

// PostRollCallReaction converts echo context to params.
func (w *ServerInterfaceWrapper) PostRollCallReaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "rollCallId" -------------
	var rollCallId RollCallId

	err = runtime.BindStyledParameterWithOptions("simple", "rollCallId", ctx.Param("rollCallId"), &rollCallId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rollCallId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PostRollCallReactionParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRollCallReaction(ctx, rollCallId, params)
	return err
}

// StreamRollCallReactions converts echo context to params.
func (w *ServerInterfaceWrapper) StreamRollCallReactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "rollCallId" -------------
	var rollCallId RollCallId

	err = runtime.BindStyledParameterWithOptions("simple", "rollCallId", ctx.Param("rollCallId"), &rollCallId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rollCallId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StreamRollCallReactions(ctx, rollCallId)
	return err
}

// GetStaffs converts echo context to params.
func (w *ServerInterfaceWrapper) GetStaffs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStaffs(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.PUT(baseURL+"/api/admin/answers/:answerId", wrapper.AdminPutAnswer)
	router.POST(baseURL+"/api/admin/camps", wrapper.AdminPostCamp)
	router.DELETE(baseURL+"/api/admin/camps/:campId", wrapper.AdminDeleteCamp)
	router.PUT(baseURL+"/api/admin/camps/:campId", wrapper.AdminPutCamp)
	router.POST(baseURL+"/api/admin/camps/:campId/images", wrapper.AdminPostImage)
	router.GET(baseURL+"/api/admin/camps/:campId/payments", wrapper.AdminGetPayments)
	router.POST(baseURL+"/api/admin/camps/:campId/payments", wrapper.AdminPostPayment)
	router.POST(baseURL+"/api/admin/camps/:campId/question-groups", wrapper.AdminPostQuestionGroup)
	router.POST(baseURL+"/api/admin/camps/:campId/roll-calls", wrapper.AdminPostRollCall)
	router.POST(baseURL+"/api/admin/camps/:campId/room-groups", wrapper.AdminPostRoomGroup)
	router.DELETE(baseURL+"/api/admin/images/:imageId", wrapper.AdminDeleteImage)
	router.PUT(baseURL+"/api/admin/images/:imageId", wrapper.AdminPutImage)
	router.DELETE(baseURL+"/api/admin/options/:optionId", wrapper.AdminDeleteOption)
	router.PUT(baseURL+"/api/admin/options/:optionId", wrapper.AdminPutOption)
	router.PUT(baseURL+"/api/admin/payments/:paymentId", wrapper.AdminPutPayment)
	router.DELETE(baseURL+"/api/admin/question-groups/:questionGroupId", wrapper.AdminDeleteQuestionGroup)
	router.PUT(baseURL+"/api/admin/question-groups/:questionGroupId", wrapper.AdminPutQuestionGroupMetadata)
	router.DELETE(baseURL+"/api/admin/questions/:questionId", wrapper.AdminDeleteQuestion)
	router.PUT(baseURL+"/api/admin/questions/:questionId", wrapper.AdminPutQuestion)
	router.GET(baseURL+"/api/admin/questions/:questionId/answers", wrapper.AdminGetAnswers)
	router.DELETE(baseURL+"/api/admin/room-groups/:roomGroupId", wrapper.AdminDeleteRoomGroup)
	router.PUT(baseURL+"/api/admin/room-groups/:roomGroupId", wrapper.AdminPutRoomGroup)
	router.POST(baseURL+"/api/admin/rooms", wrapper.AdminPostRoom)
	router.DELETE(baseURL+"/api/admin/rooms/:roomId", wrapper.AdminDeleteRoom)
	router.PUT(baseURL+"/api/admin/rooms/:roomId", wrapper.AdminPutRoom)
	router.GET(baseURL+"/api/admin/users/:userId", wrapper.AdminGetUser)
	router.PUT(baseURL+"/api/admin/users/:userId", wrapper.AdminPutUser)
	router.POST(baseURL+"/api/admin/users/:userId/messages", wrapper.AdminPostMessage)
	router.PUT(baseURL+"/api/answers/:answerId", wrapper.PutAnswer)
	router.GET(baseURL+"/api/camps", wrapper.GetCamps)
	router.GET(baseURL+"/api/camps/:campId/events", wrapper.GetEvents)
	router.POST(baseURL+"/api/camps/:campId/events", wrapper.PostEvent)
	router.GET(baseURL+"/api/camps/:campId/images", wrapper.GetImages)
	router.GET(baseURL+"/api/camps/:campId/me", wrapper.GetDashboard)
	router.GET(baseURL+"/api/camps/:campId/participants", wrapper.GetCampParticipants)
	router.GET(baseURL+"/api/camps/:campId/question-groups", wrapper.GetQuestionGroups)
	router.DELETE(baseURL+"/api/camps/:campId/register", wrapper.DeleteCampRegister)
	router.POST(baseURL+"/api/camps/:campId/register", wrapper.PostCampRegister)
	router.GET(baseURL+"/api/camps/:campId/roll-calls", wrapper.GetRollCalls)
	router.GET(baseURL+"/api/camps/:campId/room-groups", wrapper.GetRoomGroups)
	router.DELETE(baseURL+"/api/events/:eventId", wrapper.DeleteEvent)
	router.PUT(baseURL+"/api/events/:eventId", wrapper.PutEvent)
	router.GET(baseURL+"/api/images/:imageId", wrapper.GetImage)
	router.GET(baseURL+"/api/me", wrapper.GetMe)
	router.GET(baseURL+"/api/me/question-groups/:questionGroupId/answers", wrapper.GetMyAnswers)
	router.POST(baseURL+"/api/question-groups/:questionGroupId/answers", wrapper.PostAnswers)
	router.POST(baseURL+"/api/question-groups/:questionGroupId/questions", wrapper.AdminPostQuestion)
	router.GET(baseURL+"/api/questions/:questionId/answers", wrapper.GetAnswers)
	router.DELETE(baseURL+"/api/reactions/:reactionId", wrapper.DeleteReaction)
	router.PUT(baseURL+"/api/reactions/:reactionId", wrapper.PutReaction)
	router.GET(baseURL+"/api/roll-calls/:rollCallId/reactions", wrapper.GetRollCallReactions)
	router.POST(baseURL+"/api/roll-calls/:rollCallId/reactions", wrapper.PostRollCallReaction)
	router.GET(baseURL+"/api/roll-calls/:rollCallId/reactions/stream", wrapper.StreamRollCallReactions)
	router.GET(baseURL+"/api/staffs", wrapper.GetStaffs)

}
